// Code generated by protoc-gen-go. DO NOT EDIT.
// source: coredocument/coredocument.proto

package coredocumentpb

import (
	fmt "fmt"
	proto1 "github.com/centrifuge/precise-proofs/proofs/proto"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Action defines the set of actions a collaborator can/have per document.
type Action int32

const (
	Action_ACTION_INVALID Action = 0
	// read represents just reading the doc/fields
	Action_ACTION_READ Action = 1
	// read_sign represents reading as well the sign the documents. We will pick this one when requesting the signatures.
	Action_ACTION_READ_SIGN Action = 2
)

var Action_name = map[int32]string{
	0: "ACTION_INVALID",
	1: "ACTION_READ",
	2: "ACTION_READ_SIGN",
}

var Action_value = map[string]int32{
	"ACTION_INVALID":   0,
	"ACTION_READ":      1,
	"ACTION_READ_SIGN": 2,
}

func (x Action) String() string {
	return proto.EnumName(Action_name, int32(x))
}

func (Action) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{0}
}

// `CoreDocument` is a document that can be sent to different nodes and anchored
// on chain. It handles all the generic features native Centrifuge Documents support:
//
// * Merkle Roots for the document data
// * Signatures on document data
// * Access Control
type CoreDocument struct {
	// # Identifiers
	// CoreDocument has two kinds of identifiers, the `document_identifier` is assigned
	// once per document and stays the same for the lifetime of the document.
	// document_identifier is the first ID ever used to anchor the document on chain and
	// is used internally to store all future versions. The `previous_version`, `current_version`, and the
	// `next_version` refer only to a particular version.
	//
	// 32 byte value
	DocumentIdentifier []byte `protobuf:"bytes,9,opt,name=document_identifier,json=documentIdentifier,proto3" json:"document_identifier,omitempty"`
	// previous_version refers to the previous state of the document.
	// 32 byte value
	PreviousVersion []byte `protobuf:"bytes,16,opt,name=previous_version,json=previousVersion,proto3" json:"previous_version,omitempty"`
	// current_version is the version used to refer to the current state of the document.
	// 32 byte value
	CurrentVersion []byte `protobuf:"bytes,3,opt,name=current_version,json=currentVersion,proto3" json:"current_version,omitempty"`
	// next_version is the version that is going to be used for the next version if any
	// party wants to update the state.
	NextVersion []byte `protobuf:"bytes,4,opt,name=next_version,json=nextVersion,proto3" json:"next_version,omitempty"`
	// next_preimage is the sha256 pre-image of the next_version. It prevents next state commitment id(anchor id) from getting exposed.
	NextPreimage []byte `protobuf:"bytes,22,opt,name=next_preimage,json=nextPreimage,proto3" json:"next_preimage,omitempty"`
	// # Merkle roots
	// document_root the root of all roots. It's signature_root along with a list of all signatures
	DocumentRoot []byte `protobuf:"bytes,7,opt,name=document_root,json=documentRoot,proto3" json:"document_root,omitempty"`
	// signing_root is the Merkle root calculated from all fields on the document that need
	// to be signed. This is all fields except for the signatures themselves and the `document_root`.
	SigningRoot []byte `protobuf:"bytes,10,opt,name=signing_root,json=signingRoot,proto3" json:"signing_root,omitempty"`
	// previous_root is the `document_root` of the previous version of the document
	PreviousRoot []byte `protobuf:"bytes,2,opt,name=previous_root,json=previousRoot,proto3" json:"previous_root,omitempty"`
	// data_root is the Merkle root calculated for the `embedded_data` document (such as an invoice).
	DataRoot []byte `protobuf:"bytes,5,opt,name=data_root,json=dataRoot,proto3" json:"data_root,omitempty"`
	// Signatures
	// Signatures of the signature_root by centrifuge identities. This array should be sorted by the Centrifuge ID
	Signatures []*Signature `protobuf:"bytes,6,rep,name=signatures,proto3" json:"signatures,omitempty"`
	// Document a serialized document
	EmbeddedData *any.Any       `protobuf:"bytes,13,opt,name=embedded_data,json=embeddedData,proto3" json:"embedded_data,omitempty"`
	Salts        []*proto1.Salt `protobuf:"bytes,15,rep,name=salts,proto3" json:"salts,omitempty"`
	// list of roles
	Roles []*Role `protobuf:"bytes,1,rep,name=roles,proto3" json:"roles,omitempty"`
	// read rules
	ReadRules []*ReadRule `protobuf:"bytes,19,rep,name=read_rules,json=readRules,proto3" json:"read_rules,omitempty"`
	// nft list for uniqueness check
	Nfts []*NFT `protobuf:"bytes,20,rep,name=nfts,proto3" json:"nfts,omitempty"`
	// AccessTokens which have been added to this CoreDocument
	AccessTokens         []*AccessToken `protobuf:"bytes,21,rep,name=access_tokens,json=accessTokens,proto3" json:"access_tokens,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *CoreDocument) Reset()         { *m = CoreDocument{} }
func (m *CoreDocument) String() string { return proto.CompactTextString(m) }
func (*CoreDocument) ProtoMessage()    {}
func (*CoreDocument) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{0}
}

func (m *CoreDocument) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_CoreDocument.Unmarshal(m, b)
}
func (m *CoreDocument) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_CoreDocument.Marshal(b, m, deterministic)
}
func (m *CoreDocument) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CoreDocument.Merge(m, src)
}
func (m *CoreDocument) XXX_Size() int {
	return xxx_messageInfo_CoreDocument.Size(m)
}
func (m *CoreDocument) XXX_DiscardUnknown() {
	xxx_messageInfo_CoreDocument.DiscardUnknown(m)
}

var xxx_messageInfo_CoreDocument proto.InternalMessageInfo

func (m *CoreDocument) GetDocumentIdentifier() []byte {
	if m != nil {
		return m.DocumentIdentifier
	}
	return nil
}

func (m *CoreDocument) GetPreviousVersion() []byte {
	if m != nil {
		return m.PreviousVersion
	}
	return nil
}

func (m *CoreDocument) GetCurrentVersion() []byte {
	if m != nil {
		return m.CurrentVersion
	}
	return nil
}

func (m *CoreDocument) GetNextVersion() []byte {
	if m != nil {
		return m.NextVersion
	}
	return nil
}

func (m *CoreDocument) GetNextPreimage() []byte {
	if m != nil {
		return m.NextPreimage
	}
	return nil
}

func (m *CoreDocument) GetDocumentRoot() []byte {
	if m != nil {
		return m.DocumentRoot
	}
	return nil
}

func (m *CoreDocument) GetSigningRoot() []byte {
	if m != nil {
		return m.SigningRoot
	}
	return nil
}

func (m *CoreDocument) GetPreviousRoot() []byte {
	if m != nil {
		return m.PreviousRoot
	}
	return nil
}

func (m *CoreDocument) GetDataRoot() []byte {
	if m != nil {
		return m.DataRoot
	}
	return nil
}

func (m *CoreDocument) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *CoreDocument) GetEmbeddedData() *any.Any {
	if m != nil {
		return m.EmbeddedData
	}
	return nil
}

func (m *CoreDocument) GetSalts() []*proto1.Salt {
	if m != nil {
		return m.Salts
	}
	return nil
}

func (m *CoreDocument) GetRoles() []*Role {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *CoreDocument) GetReadRules() []*ReadRule {
	if m != nil {
		return m.ReadRules
	}
	return nil
}

func (m *CoreDocument) GetNfts() []*NFT {
	if m != nil {
		return m.Nfts
	}
	return nil
}

func (m *CoreDocument) GetAccessTokens() []*AccessToken {
	if m != nil {
		return m.AccessTokens
	}
	return nil
}

type AccessToken struct {
	// The identifier is an internal 256bit word
	Identifier []byte `protobuf:"bytes,1,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// The identity granting access to the document
	Granter []byte `protobuf:"bytes,3,opt,name=granter,proto3" json:"granter,omitempty"`
	// The identity being granted access to the document
	Grantee []byte `protobuf:"bytes,4,opt,name=grantee,proto3" json:"grantee,omitempty"`
	// Role identifier is the identifier on the read rule that this token should be mapped to
	RoleIdentifier []byte `protobuf:"bytes,5,opt,name=role_identifier,json=roleIdentifier,proto3" json:"role_identifier,omitempty"`
	// Original identifier of the document
	DocumentIdentifier []byte `protobuf:"bytes,2,opt,name=document_identifier,json=documentIdentifier,proto3" json:"document_identifier,omitempty"`
	// Cryptographic signature that an access token is valid
	Signature []byte `protobuf:"bytes,6,opt,name=signature,proto3" json:"signature,omitempty"`
	// The public key of the signed message
	Key                  []byte   `protobuf:"bytes,7,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AccessToken) Reset()         { *m = AccessToken{} }
func (m *AccessToken) String() string { return proto.CompactTextString(m) }
func (*AccessToken) ProtoMessage()    {}
func (*AccessToken) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{1}
}

func (m *AccessToken) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AccessToken.Unmarshal(m, b)
}
func (m *AccessToken) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AccessToken.Marshal(b, m, deterministic)
}
func (m *AccessToken) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessToken.Merge(m, src)
}
func (m *AccessToken) XXX_Size() int {
	return xxx_messageInfo_AccessToken.Size(m)
}
func (m *AccessToken) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessToken.DiscardUnknown(m)
}

var xxx_messageInfo_AccessToken proto.InternalMessageInfo

func (m *AccessToken) GetIdentifier() []byte {
	if m != nil {
		return m.Identifier
	}
	return nil
}

func (m *AccessToken) GetGranter() []byte {
	if m != nil {
		return m.Granter
	}
	return nil
}

func (m *AccessToken) GetGrantee() []byte {
	if m != nil {
		return m.Grantee
	}
	return nil
}

func (m *AccessToken) GetRoleIdentifier() []byte {
	if m != nil {
		return m.RoleIdentifier
	}
	return nil
}

func (m *AccessToken) GetDocumentIdentifier() []byte {
	if m != nil {
		return m.DocumentIdentifier
	}
	return nil
}

func (m *AccessToken) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *AccessToken) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

// Signature contains the entity ID, public key used and signature)
type Signature struct {
	// `entity_id` is the CentrifugeID of the entity signing the document.
	EntityId []byte `protobuf:"bytes,1,opt,name=entity_id,json=entityId,proto3" json:"entity_id,omitempty"`
	// `public_key` is the public key of the `entity` used for signing the `CoreDocument`
	PublicKey            []byte               `protobuf:"bytes,2,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	Signature            []byte               `protobuf:"bytes,3,opt,name=signature,proto3" json:"signature,omitempty"`
	Timestamp            *timestamp.Timestamp `protobuf:"bytes,4,opt,name=timestamp,proto3" json:"timestamp,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{2}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetEntityId() []byte {
	if m != nil {
		return m.EntityId
	}
	return nil
}

func (m *Signature) GetPublicKey() []byte {
	if m != nil {
		return m.PublicKey
	}
	return nil
}

func (m *Signature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Signature) GetTimestamp() *timestamp.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

// Roles holds a list of collaborators, NFTs, and/or access tokens.
type Role struct {
	// Index of the position of the Role within the coredocument
	RoleKey []byte `protobuf:"bytes,1,opt,name=role_key,json=roleKey,proto3" json:"role_key,omitempty"`
	// collaborators holds the list of document collaborators
	Collaborators [][]byte `protobuf:"bytes,3,rep,name=collaborators,proto3" json:"collaborators,omitempty"`
	// nfts is a list of registry address/tokenID pairs.
	// For easier verification in merkle proofs, the values are simply concatenated with the first 22 bytes being the NFT registry and the remaining 32 bytes the tokenID.
	Nfts                 [][]byte `protobuf:"bytes,4,rep,name=nfts,proto3" json:"nfts,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Role) Reset()         { *m = Role{} }
func (m *Role) String() string { return proto.CompactTextString(m) }
func (*Role) ProtoMessage()    {}
func (*Role) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{3}
}

func (m *Role) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Role.Unmarshal(m, b)
}
func (m *Role) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Role.Marshal(b, m, deterministic)
}
func (m *Role) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Role.Merge(m, src)
}
func (m *Role) XXX_Size() int {
	return xxx_messageInfo_Role.Size(m)
}
func (m *Role) XXX_DiscardUnknown() {
	xxx_messageInfo_Role.DiscardUnknown(m)
}

var xxx_messageInfo_Role proto.InternalMessageInfo

func (m *Role) GetRoleKey() []byte {
	if m != nil {
		return m.RoleKey
	}
	return nil
}

func (m *Role) GetCollaborators() [][]byte {
	if m != nil {
		return m.Collaborators
	}
	return nil
}

func (m *Role) GetNfts() [][]byte {
	if m != nil {
		return m.Nfts
	}
	return nil
}

type ReadRule struct {
	Roles                [][]byte `protobuf:"bytes,2,rep,name=roles,proto3" json:"roles,omitempty"`
	Action               Action   `protobuf:"varint,4,opt,name=action,proto3,enum=coredocument.Action" json:"action,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ReadRule) Reset()         { *m = ReadRule{} }
func (m *ReadRule) String() string { return proto.CompactTextString(m) }
func (*ReadRule) ProtoMessage()    {}
func (*ReadRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{4}
}

func (m *ReadRule) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ReadRule.Unmarshal(m, b)
}
func (m *ReadRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ReadRule.Marshal(b, m, deterministic)
}
func (m *ReadRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadRule.Merge(m, src)
}
func (m *ReadRule) XXX_Size() int {
	return xxx_messageInfo_ReadRule.Size(m)
}
func (m *ReadRule) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadRule.DiscardUnknown(m)
}

var xxx_messageInfo_ReadRule proto.InternalMessageInfo

func (m *ReadRule) GetRoles() [][]byte {
	if m != nil {
		return m.Roles
	}
	return nil
}

func (m *ReadRule) GetAction() Action {
	if m != nil {
		return m.Action
	}
	return Action_ACTION_INVALID
}

type NFT struct {
	RegistryId           []byte   `protobuf:"bytes,1,opt,name=registry_id,json=registryId,proto3" json:"registry_id,omitempty"`
	TokenId              []byte   `protobuf:"bytes,2,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NFT) Reset()         { *m = NFT{} }
func (m *NFT) String() string { return proto.CompactTextString(m) }
func (*NFT) ProtoMessage()    {}
func (*NFT) Descriptor() ([]byte, []int) {
	return fileDescriptor_eb191193ab8e2cd4, []int{5}
}

func (m *NFT) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NFT.Unmarshal(m, b)
}
func (m *NFT) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NFT.Marshal(b, m, deterministic)
}
func (m *NFT) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NFT.Merge(m, src)
}
func (m *NFT) XXX_Size() int {
	return xxx_messageInfo_NFT.Size(m)
}
func (m *NFT) XXX_DiscardUnknown() {
	xxx_messageInfo_NFT.DiscardUnknown(m)
}

var xxx_messageInfo_NFT proto.InternalMessageInfo

func (m *NFT) GetRegistryId() []byte {
	if m != nil {
		return m.RegistryId
	}
	return nil
}

func (m *NFT) GetTokenId() []byte {
	if m != nil {
		return m.TokenId
	}
	return nil
}

func init() {
	proto.RegisterEnum("coredocument.Action", Action_name, Action_value)
	proto.RegisterType((*CoreDocument)(nil), "coredocument.CoreDocument")
	proto.RegisterType((*AccessToken)(nil), "coredocument.AccessToken")
	proto.RegisterType((*Signature)(nil), "coredocument.Signature")
	proto.RegisterType((*Role)(nil), "coredocument.Role")
	proto.RegisterType((*ReadRule)(nil), "coredocument.ReadRule")
	proto.RegisterType((*NFT)(nil), "coredocument.NFT")
}

func init() { proto.RegisterFile("coredocument/coredocument.proto", fileDescriptor_eb191193ab8e2cd4) }

var fileDescriptor_eb191193ab8e2cd4 = []byte{
	// 838 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x94, 0xcd, 0x6f, 0xe3, 0x44,
	0x18, 0xc6, 0x71, 0xd3, 0xa4, 0xcd, 0x1b, 0xa7, 0xcd, 0xce, 0x66, 0x17, 0xb7, 0x7c, 0x34, 0x04,
	0xc4, 0x86, 0x0a, 0x12, 0xa9, 0x08, 0xc1, 0x01, 0x21, 0x92, 0x96, 0x45, 0x16, 0x28, 0x54, 0x6e,
	0xb4, 0x07, 0x38, 0x58, 0x13, 0x7b, 0x1a, 0x59, 0x75, 0x3c, 0xd6, 0xcc, 0x78, 0x45, 0xfe, 0x1a,
	0x38, 0x72, 0xdc, 0x33, 0xb7, 0xfe, 0x3d, 0x9c, 0x7b, 0x47, 0xf3, 0xe5, 0x8f, 0xa2, 0xe5, 0x94,
	0x99, 0xe7, 0xfd, 0xbd, 0xcf, 0x7c, 0xe4, 0x19, 0xc3, 0x59, 0x44, 0x19, 0x89, 0x69, 0x54, 0x6c,
	0x49, 0x26, 0x66, 0xf5, 0xc9, 0x34, 0x67, 0x54, 0x50, 0xe4, 0xd6, 0xb5, 0xd3, 0x93, 0x0d, 0xa5,
	0x9b, 0x94, 0xcc, 0x54, 0x6d, 0x5d, 0xdc, 0xce, 0x70, 0xb6, 0xd3, 0xe0, 0xe9, 0xd9, 0xe3, 0x92,
	0x48, 0xb6, 0x84, 0x0b, 0xbc, 0xcd, 0x0d, 0xf0, 0x22, 0x67, 0x24, 0x4a, 0x38, 0xf9, 0x22, 0x67,
	0x94, 0xde, 0xf2, 0x59, 0xf5, 0x23, 0xa8, 0x9e, 0x18, 0xf0, 0xd3, 0xff, 0x03, 0x39, 0x4e, 0xcd,
	0xd6, 0xc6, 0x6f, 0x3a, 0xe0, 0x5e, 0x52, 0x46, 0xae, 0xcc, 0xee, 0xd0, 0x0c, 0x9e, 0xda, 0x9d,
	0x86, 0x49, 0x4c, 0x32, 0x91, 0xdc, 0x26, 0x84, 0x79, 0xdd, 0x91, 0x33, 0x71, 0x03, 0x64, 0x4b,
	0x7e, 0x59, 0x41, 0x9f, 0xc1, 0x20, 0x67, 0xe4, 0x75, 0x42, 0x0b, 0x1e, 0xbe, 0x26, 0x8c, 0x27,
	0x34, 0xf3, 0x06, 0x8a, 0x3e, 0xb6, 0xfa, 0x2b, 0x2d, 0xa3, 0x17, 0x70, 0x1c, 0x15, 0x8c, 0x49,
	0x6b, 0x4b, 0xb6, 0x14, 0x79, 0x64, 0x64, 0x0b, 0x7e, 0x04, 0x6e, 0x46, 0x7e, 0xaf, 0xa8, 0x7d,
	0x45, 0xf5, 0xa4, 0x66, 0x91, 0x8f, 0xa1, 0xaf, 0x90, 0x9c, 0x91, 0x64, 0x8b, 0x37, 0xc4, 0x7b,
	0xae, 0x18, 0xd5, 0x77, 0x6d, 0x34, 0x74, 0x0e, 0xfd, 0xf2, 0x30, 0x8c, 0x52, 0xe1, 0x1d, 0x48,
	0x68, 0xd1, 0xfe, 0xf3, 0xfe, 0x01, 0x9c, 0xc0, 0xb5, 0xb5, 0x80, 0x52, 0x81, 0x26, 0xe0, 0xf2,
	0x64, 0x93, 0x25, 0xd9, 0x46, 0xa3, 0x50, 0x47, 0x7b, 0xa6, 0xa4, 0xc8, 0x73, 0xe8, 0x97, 0x27,
	0x56, 0xe8, 0x9e, 0x46, 0xff, 0xd2, 0xae, 0xb6, 0xa6, 0xd8, 0x31, 0x74, 0x63, 0x2c, 0xb0, 0xe6,
	0xda, 0x75, 0xcb, 0x43, 0xa9, 0x2b, 0xe6, 0x3b, 0x00, 0x69, 0x8f, 0x45, 0xc1, 0x08, 0xf7, 0x3a,
	0xa3, 0xd6, 0xa4, 0x77, 0xf1, 0xee, 0xb4, 0x91, 0xa3, 0x1b, 0x5b, 0xb7, 0xdd, 0xb5, 0x0e, 0xf4,
	0x3d, 0xf4, 0xc9, 0x76, 0x4d, 0xe2, 0x98, 0xc4, 0xa1, 0x34, 0xf5, 0xfa, 0x23, 0x67, 0xd2, 0xbb,
	0x18, 0x4e, 0x75, 0x9a, 0xa6, 0x36, 0x4d, 0xd3, 0x79, 0xb6, 0x2b, 0xcf, 0x6e, 0x3b, 0xae, 0xb0,
	0xc0, 0x68, 0x0c, 0x6d, 0x99, 0x09, 0xee, 0x1d, 0xab, 0xc5, 0xdd, 0xa9, 0x8e, 0xcb, 0xf4, 0x06,
	0xa7, 0x22, 0xd0, 0x25, 0xf4, 0x2d, 0xb4, 0x19, 0x4d, 0x09, 0xf7, 0x1c, 0xc5, 0xa0, 0xe6, 0x06,
	0x03, 0x9a, 0x92, 0x05, 0x7a, 0x73, 0xff, 0x00, 0xa3, 0xbf, 0xef, 0x1f, 0xe0, 0x50, 0xa2, 0xe1,
	0x1d, 0xd9, 0x05, 0xba, 0x09, 0x7d, 0x05, 0xc0, 0x08, 0x8e, 0x43, 0x56, 0x48, 0x8b, 0xa7, 0xca,
	0xe2, 0xf9, 0x23, 0x0b, 0x82, 0xe3, 0xa0, 0x48, 0x49, 0xd0, 0x65, 0x66, 0x24, 0x17, 0xdd, 0xcf,
	0x6e, 0x05, 0xf7, 0x86, 0xaa, 0xe1, 0x49, 0xb3, 0x61, 0xf9, 0x72, 0xb5, 0x78, 0x56, 0x2e, 0xd9,
	0x63, 0x64, 0x93, 0x70, 0xc1, 0x76, 0x61, 0x12, 0x07, 0xaa, 0x0b, 0xad, 0xa0, 0x8f, 0xa3, 0x88,
	0x70, 0x1e, 0x0a, 0x7a, 0x47, 0x32, 0xee, 0x3d, 0x53, 0x36, 0x27, 0x4d, 0x9b, 0xb9, 0x42, 0x56,
	0x92, 0x58, 0x0c, 0x4b, 0x3b, 0xa8, 0xc2, 0x1f, 0xb8, 0xb8, 0x42, 0xf8, 0xf8, 0x1f, 0x07, 0x7a,
	0xb5, 0x1e, 0xf4, 0x61, 0x9d, 0xf5, 0x1c, 0x15, 0xc3, 0x9a, 0x82, 0x3c, 0x38, 0xd8, 0x30, 0x9c,
	0x09, 0xc2, 0x4c, 0xda, 0xed, 0xb4, 0xaa, 0x10, 0x93, 0x70, 0x3b, 0x95, 0x2f, 0x45, 0xdd, 0x60,
	0xcd, 0xb8, 0xad, 0x5f, 0x8a, 0x94, 0x6b, 0xaf, 0xef, 0x2d, 0xcf, 0x75, 0xef, 0xad, 0xcf, 0xf5,
	0x7d, 0xe8, 0x96, 0xd1, 0xf1, 0x3a, 0x0a, 0xab, 0x04, 0x34, 0x80, 0xd6, 0x1d, 0xd9, 0xe9, 0x67,
	0x12, 0xc8, 0xe1, 0xf8, 0x0f, 0x07, 0xba, 0x65, 0xfa, 0xd0, 0x7b, 0xd0, 0x95, 0x4e, 0x42, 0x5e,
	0xb2, 0x39, 0xea, 0xa1, 0x16, 0xfc, 0x18, 0x7d, 0x00, 0x90, 0x17, 0xeb, 0x34, 0x89, 0xe4, 0x1f,
	0x6f, 0xb6, 0xd0, 0xd5, 0xca, 0x4f, 0x64, 0xd7, 0x5c, 0xb9, 0xf5, 0x78, 0xe5, 0x6f, 0xa0, 0x5b,
	0x7e, 0xec, 0xd4, 0x6d, 0xf4, 0x2e, 0x4e, 0xff, 0x13, 0xe0, 0x95, 0x25, 0x82, 0x0a, 0x1e, 0xff,
	0x06, 0xfb, 0x32, 0x7d, 0xe8, 0xa4, 0x4a, 0x9d, 0xd9, 0xda, 0x81, 0x9c, 0xcb, 0xa5, 0x3f, 0x81,
	0x7e, 0x44, 0xd3, 0x14, 0xaf, 0x29, 0xc3, 0x82, 0x32, 0xee, 0xb5, 0x46, 0xad, 0x89, 0x1b, 0x34,
	0x45, 0x84, 0x4c, 0xd8, 0xf6, 0x55, 0x51, 0x8d, 0xc7, 0x4b, 0x38, 0xb4, 0xb9, 0x44, 0x43, 0xfb,
	0x02, 0xf6, 0x14, 0x60, 0x92, 0xfd, 0x39, 0x74, 0x70, 0x24, 0xec, 0x57, 0xea, 0xe8, 0x62, 0xf8,
	0x38, 0x5d, 0xb2, 0x16, 0x18, 0x66, 0x3c, 0x87, 0xd6, 0xf2, 0xe5, 0x0a, 0x9d, 0x35, 0xe2, 0x6a,
	0x43, 0x63, 0x25, 0x3f, 0x96, 0x87, 0x51, 0x99, 0x95, 0x55, 0x7d, 0x93, 0x07, 0x6a, 0xee, 0xc7,
	0xe7, 0x97, 0xd0, 0xd1, 0xa6, 0x08, 0xc1, 0xd1, 0xfc, 0x72, 0xe5, 0xff, 0xb2, 0x0c, 0xfd, 0xe5,
	0xab, 0xf9, 0xcf, 0xfe, 0xd5, 0xe0, 0x1d, 0x74, 0x0c, 0x3d, 0xa3, 0x05, 0x3f, 0xcc, 0xaf, 0x06,
	0x0e, 0x1a, 0xc2, 0xa0, 0x26, 0x84, 0x37, 0xfe, 0x8f, 0xcb, 0xc1, 0xde, 0xe2, 0x6b, 0x18, 0x44,
	0x74, 0xdb, 0xd8, 0xea, 0xe2, 0xc9, 0x65, 0x6d, 0x76, 0x2d, 0xef, 0xfc, 0xda, 0xf9, 0xf5, 0xa8,
	0x8e, 0xe4, 0xeb, 0x75, 0x47, 0xfd, 0x19, 0x5f, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x30, 0xfe,
	0x37, 0x84, 0xf5, 0x06, 0x00, 0x00,
}
